import logging
import io
import time
from subprocess import Popen, PIPE
from pathlib import Path
from IPython.display import display, FileLink
import nbformat
from nbconvert.preprocessors import ExecutePreprocessor

from dsutils.general import general_utils
from dsutils.setup import log
logger = logging.getLogger(__name__)


def trust_notebook(path):
    """
    Mark a Jupyter notebook as trusted.
    """
    cmd = ["jupyter trust", path]
    logger.debug("trust_notebook cmd: {}".format(cmd))

    p = Popen(["jupyter trust", path], stdin=PIPE,
              stdout=PIPE, stderr=PIPE, shell=True)
    output, err = p.communicate(
        b"input data that is passed to subprocess' stdin")
    return p.returncode


def run_notebook(nb_path,
                 out_dir=None,
                 nb_suffix='out',
                 nb_kwargs=None,
                 nb_tstamp=False,
                 hide_input=False,
                 insert_pos=1,
                 kernel_name='python',
                 timeout=3600,
                 execute_kwargs=None,
                 trust=True):
    """Runs a notebook and saves the output in a new notebook.

    Executes a notebook, optionally passing "arguments" in a way roughly
    similar to passing arguments to a function.
    Notebook arguments are passed in a dictionary (`nb_kwargs`) which is
    converted to a string containing python code, then inserted in the notebook
    as a code cell. The code contains only assignments of variables which
    can be used to control the execution of a suitably written notebook. When
    calling a notebook, you need to know which arguments (variables) to pass.
    Differently from functions, no check on the input arguments is performed.
    The "notebook signature" is only informally declared in a conventional
    markdown cell at the beginning of the notebook.

    Arguments:
        nb_path (path-like object): path of the notebook to be
            executed. Valid values are strings or pathlib.Path objects.
        nb_suffix (string): suffix to append to the file name of the executed
            notebook.
        nb_kwargs (dict or None): If not None, this dict is converted to a
            string of python assignments with keys representing variables
            names and values variables content. This string is inserted as
            code-cell in the notebook to be executed.
        insert_pos (int): position of insertion of the code-cell containing
            the input arguments. Default is 1 (i.e. second cell). With this
            default, the input notebook can define, in the first cell, default
            values of input arguments (used when the notebook is executed
            with no arguments or through the Notebook GUI).
        timeout (int): timeout in seconds after which the execution is aborted.
        execute_kwargs (dict): additional arguments passed to
            `ExecutePreprocessor`.
        out_dir (path-like or None): folder where to save the output
            notebook. If None, saves the notebook in the same folder as
            the template. Valid values are strings or pathlib.Path objects.
        hide_input (bool): whether to create a notebook with input cells
            hidden (useful to remind user that the auto-generated output
            is not meant to have the code edited.
    """

    nb_suffix = nb_suffix or 'out'
    kernel_name = kernel_name or 'python'
    timeout = timeout or 3600
    nb_tstamp = nb_tstamp if nb_tstamp is not None else False
    hide_input = hide_input if hide_input is not None else True
    insert_pos = insert_pos or 1
    nb_kwargs = nb_kwargs or dict()
    execute_kwargs = execute_kwargs or dict()

    timestamp_cell = "**Execution:**\n\n* Started: {started}\n* Ended: {ended}\n\n**Duration:** {duration} seconds.\n\n**Autogenerated from:** [{in_path}](in_path)"

    if nb_kwargs is not None:
        header = '# cell inserted during automated execution with new args.'
        code = general_utils.dict_to_code(nb_kwargs)
        code_cell = '\n'.join((header, code))

    # check source notebook exists
    nb_path = Path(nb_path)
    if not nb_path.is_file():
        raise Exception("Path '{0}' not found.".format(nb_path))
    logger.debug("input nb_path: {}".format(nb_path))

    # output destination checks
    logger.debug("out_dir: {}".format(out_dir))
    if out_dir is None:
        out_dir = nb_path.parent.absolute()
    out_dir = Path(out_dir)
    if not out_dir.exists():
        raise Exception("Output path {0} not found.".format(out_dir))
    logger.debug("out_dir: {}".format(out_dir))

    out_path = out_dir / nb_path.stem

    # build destination notebook path
    if not nb_tstamp:
        out_nb_path = '{0}-{1}.ipynb'.format(out_path, nb_suffix)
    else:
        now = time.strftime('%Y-%m-%d %H:%M', time.gmtime())
        out_nb_path = '{0}-{1}-{2}.ipynb'.format(
            out_path,
            nb_suffix,
            now)
    out_nb_path = Path(out_nb_path)
    logger.debug("out_nb_path: {}".format(out_nb_path))
    logger.debug("out_nb_path.absolute(): {}".format(out_nb_path.absolute()))

    # create processor
    if execute_kwargs is None:
        execute_kwargs = {}

    ep = ExecutePreprocessor(timeout=timeout,
                             kernel_name=kernel_name,
                             **execute_kwargs)

    # open source notebook for processing
    with io.open(nb_path.absolute(), 'rt') as f:
        nb = nbformat.read(f, as_version=4)

    if hide_input:
        nb["metadata"].update({"hide_input": True})

    if len(nb_kwargs) > 0:
        nb['cells'].insert(insert_pos, nbformat.v4.new_code_cell(code_cell))

    start_time = time.time()
    try:
        # Execute the notebook
        ep.preprocess(nb, {'metadata': {'path': './'}})
    except Exception:
        # Execution failed, print a message then raise.
        msg = 'Error executing the notebook "%s".\n\n' % nb_path
        msg += 'See notebook "%s" for the traceback.' % out_nb_path.absolute()
        logger.error(msg)
        raise Exception(msg)
    else:
        # On successful execution, add timestamping cell
        end_time = time.time()
        duration = end_time - start_time
        timestamp_cell = timestamp_cell.format(
            started=time.strftime('%Y-%m-%d %H:%M:%S GMT',
                                  time.gmtime(start_time)),
            ended=time.strftime('%Y-%m-%d %H:%M:%S GMT',
                                time.gmtime(end_time)),
            duration=round(duration, 1),
            in_path=nb_path)
        nb['cells'].insert(0, nbformat.v4.new_markdown_cell(timestamp_cell))

    finally:
        # Save the notebook even when it raises an error
        nbformat.write(nb, str(out_nb_path.absolute()))
        display(FileLink(str(out_nb_path.relative_to(out_dir))))
